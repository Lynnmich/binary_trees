# Binary_trees
**These tasks involved implementing various functions for working with binary trees, such as creating nodes, inserting nodes, deleting trees, and traversing trees.**

**Here is a summary of each task and its purpose:**

***1. New node:***

**Function:** binary_tree_node

Creates a new binary tree node with the given parent and value.

Returns a pointer to the new node.

***2. Insert left:***

**Function:** binary_tree_insert_left

Inserts a new node as the left child of a given parent node.

Returns a pointer to the created node.

***3. Insert right:***

**Function:** binary_tree_insert_right

Inserts a new node as the right child of a given parent node.

Returns a pointer to the created node.

***4. Delete:***

**Function:** binary_tree_delete

Deletes an entire binary tree, freeing all allocated memory.

***5. Is leaf:***

**Function:** binary_tree_is_leaf

Checks if a given node is a leaf node (has no children).

Returns 1 if the node is a leaf, 0 otherwise.

***6. Is root:***

**Function:** binary_tree_is_root

Checks if a given node is a root node (has no parent).

Returns 1 if the node is a root, 0 otherwise.

***7. Pre-order traversal:***

**Function:** binary_tree_preorder

Traverses a binary tree using pre-order traversal and calls a provided function on each node.

The provided function takes an integer value as a parameter.

***Each task has a corresponding main file that demonstrates the usage of the implemented functions. The examples include creating binary trees, inserting nodes, performing traversal, and checking conditions like leaf and root status.***
